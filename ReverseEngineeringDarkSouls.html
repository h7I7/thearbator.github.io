<!DOCTYPE HTML>
<!--
	Phantom by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Reverse Engineering Dark Souls</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">
		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<div class="inner">

							<!-- Logo -->
								<a href="./" class="logo">
									<span class="title">Lily Raeburn</span>
								</a>

							<!-- Nav -->
								<nav>
									<ul>
										<li><a href="#menu">Menu</a></li>
									</ul>
								</nav>

						</div>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<h2>Menu</h2>
						<ul>
							<li><a href="./">Home</a></li>
                            <li><a href="About.html">About/CV</a></li>
							<li><a href="https://github.com/h7I7" target="_blank">GitHub</a></li>
                            <li><a href="http://www.linkedin.com/in/lilyraeburn" target="_blank">LinkedIn Profile</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">
						<div class="inner">
							<h1>Reverse Engineering Dark Souls</h1>
                            <div>
                                <center>
                                    <iframe width="1120" height="615" src="https://www.youtube.com/embed/-UZvWtUi-Jg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
                                </center>
                            </div>
                            <br>
                            
							<div>
                                <center>
                                    <h2><a href="https://github.com/h7I7/Reverse-Engineering-Dark-Souls" target="_blank">GITHUB REPO</a></h2>
                                </center>
								<p><b>Note:</b> While this write-up includes technical details that could potentially be misused in Dark Souls PvP, I urge you not to cheat in games. This project was conducted purely for educational purposes.</p>
								<a><h3>Controls</h3></a>
                                <ul>
                                    <li><b>F1</b> - Toggle Infinite Health</li>
                                </ul>
							</div>
							<br>
							<a><h2>Introduction</h2></a>
                            <p>This is, admittedly, a small-scale project, but the bulk of the time was spent dissecting the Dark Souls Remastered disassembly and gradually understanding its inner workings. One of the key challenges was attaching a debugger which requires DBVM, a risky process that can occasionally result in a Blue Screen of Death. Despite these difficulties, the experience was invaluable, and I’m excited about the possibility of taking on similar challenges in the future. Ideas like infinite stamina or a damage multiplier sound like they'd make for interesting follow-up projects!</p>
							<br>
							<a><h2>Requirements</h2></a>
							<p>To complete this project, you'll need a copy of Dark Souls Remastered and Cheat Engine. Although Cheat Engine is often viewed as just a tool for game cheats, it's actually quite sophisticated for reverse engineering. Its simplicity in enabling cheats is not a flaw, but rather a testament to its effectiveness as a powerful hacking tool.</p>
							<p>For the sake of brevity, I’ll assume you are already familiar with Dark Souls Remastered and general video game mechanics, so I won’t be covering details like game mechanics, menus, locations, or stats. Similarly, this guide won’t focus on the ins and outs of Cheat Engine as a tool. Instead, I’ll be explaining the specific steps I took using Cheat Engine to reverse engineer this application, highlighting the underlying technology and the reverse engineering process rather than the software itself.</p>
							<br>
							<a><h2>Finding the Health Value</h2></a>
							<p>To get started, open Dark Souls Remastered and Cheat Engine, then attach Cheat Engine to the game process (DARK SOULS™: REMASTERED or DarkSoulsRemastered.exe) using the computer icon at the top left [1]. After attaching, create a character and move to a convenient location for testing (I used Firelink Shrine for easy access to a bonfire and enemies).</p>
							<p>Next, find your current health value in the game [2] and enter it into Cheat Engine’s "Value" field [3], ensuring the scan type is set to “Exact Value.” Since most values in Dark Souls are likely stored as 4-byte integers (a common data type in C++), you can use that as a starting point. If you don’t find the value using 4 bytes, try other types, as discussed later.</p>
							<p>A 4-byte integer (int32) occupies 32 bits of memory (4 bytes = 32 bits). If the value doesn't show up, scan using other common data types like float or double.</p>
							<p>After clicking "New Scan" and/or "First Scan" [4], a list of matching addresses will appear. These addresses correspond to memory locations where the health value might be stored. Now, take damage in the game (I did this by getting hit by a skeleton) and use "Next Scan" to search for the updated health value [5].</p>
							<center>
							<a href="images/Reverse%20Engineering%20Dark%20Souls/FindingHealth.jpg" target="_Blank">
							<span><img src="images/Reverse%20Engineering%20Dark%20Souls/FindingHealth.jpg" class="EHG" alt="" /></span>
							</a>
							</center>
							<p>Keep in mind that some of the values you find may only be used for display purposes, so you'll need to do a bit of extra work to locate the actual health value. Try modifying the values to see if anything changes in-game, but be cautious as making drastic changes could cause the game to crash.</p>
							<br>
							<a><h2>Finding the Health Pointer Chain</h2></a>
							<p>We now have our health value in Cheat Engine, but if we were to close and reopen Dark Souls, that value would no longer be valid. This is because the health value is stored on the heap, which is dynamically allocated memory. To solve this, we need to find a series of pointers that lead to our health value (typically called a pointer chain), starting from a stable memory location on the stack. This allows us to reliably locate the correct memory address every time the program runs, as the heap’s dynamic memory allocation changes between runs.</p>
							<p>The next step involves attaching a debugger to Dark Souls. As mentioned earlier, this requires DBVM, which carries some risks, such as system crashes. You can attempt to attach a regular debugger, but the game will most likely detect it and crash as a result. Additionally, if you're trying any of these methods, make sure to start the game in 'Offline Mode' to avoid getting banned from Dark Souls. For more information about DBVM, you can read <u><a href="https://wiki.cheatengine.org/index.php?title=DBVM" target="_Blank">this page on the Cheat Engine Wiki.</a></u></p>
							<p>To find our health pointer chain, we need to identify the code that accesses the memory address where the health value is stored. To do this, right-click the value in Cheat Engine and select "Find out what writes to this address" [1]. A pop-up will prompt you to attach a debugger, and you’ll get a warning about DBVM, click "Yes" to both. Once the DBVM debugger is running, try to move quickly, as leaving it running for too long can lead to a system crash. Be sure to take some damage in-game and then stop the debugger.</p>
							<p>You’ll now see a window displaying the ‘Counts’ and ‘Instructions’ [2]. The ‘Count’ shows how many times the code was executed, while the ‘Instruction’ lists the memory location, hex opcodes, and the ASM disassembly. Double-click on the instruction with the fewest calls or the one triggered when you took damage, as this is likely the one tied to your health value. A new window will appear showing the disassembly around the selected instruction [3] as well as the stack frame at the time the instruction was executed [4]. For more information on stack frame layout in x86-64 architecture, check out <a href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64" target="_Blank">this article by Eli Bendersky</a>, particularly the section titled 'Registers galore'.</p>
							<p>In this 'Extra Info' window you can also see that Cheat Engine has kindly suggested the value of the pointer needed to find this address [5]. We won't be using this though as I am interested in finding this value manually.</p>
							<center>
							<a href="images/Reverse%20Engineering%20Dark%20Souls/FindingHealthPointer1.jpg" target="_Blank">
							<span><img src="images/Reverse%20Engineering%20Dark%20Souls/FindingHealthPointer1.jpg" class="EHG" alt="" /></span>
							</a>
							</center>
							<p>For example, the instruction might look like this: <code>mov [rbx+000003E8],eax</code>. The square brackets <code>[]</code> denote a pointer dereference, which is the equivalent of the <code>-></code> and <code>*</code> pointer operators in C++.</p>
							<p>Here, the value in the <code>eax</code> register is being written to the memory location <code>rbx+000003E8</code>, which corresponds to the current address <code>0D51B538</code>. We can treat this like a simple equation: <code>rbx+000003E8 = 0D51B538</code></p>
							<p>This allows us to calculate the base pointer by subtracting the offset: <code>rbx = 0D51B538 - 000003E8 = 0D51B150</code></p>
							<p>To be fair, we could have simply looked at the <code>rbx</code> register, as it already contains the base pointer, which is exactly what Cheat Engine suggested in the first place. However, going through the manual process of calculating it helps reinforce understanding of how these memory addresses and pointers work in practice.</p>
							<hr>
							<br>
							<p>So now we have the base pointer for our health, we're done! Or are we... Unfortunately, the base pointer is still on the heap, meaning it will be invalid after a restart. What we need is a pointer on the stack, which will look like this: <code>DarkSoulsRemastered.exe+???????</code>. These pointers are the holy grail and never change location between application runs. </p>
							<p>Let's recap, from our example we now know that <code><b>0D51B150</b>+000003E8 = 0D51B538</code>. So now we want to search for our base pointer: <code><b>0D51B150</b></code>. To do this, check the 'Hex' box in Cheat Engine, paste the base pointer into the search box, and start a scan. This will search for memory addresses that point to our base pointer.</p>
							<p>We now have a list of all the values that are a pointer to our base pointer. There are quite a lot of results, so we’ll need to narrow them down. To start I would suggest hitting "Next Scan" a few times but this probably won't do much, so we need to put our detective hats on. This is usually the point where I will get stuck for hours, days, weeks, or even much longer. There is no guarantee that we will find what we need, there might be red herrings along the way, and some applications employ measures that make it harder to reverse them. More on that a bit later.</p>
							<p>One approach would be to go through all of these values one-by-one and run 'Find out what accesses this address' on each of them, scouring through the instructions and reading the disassembly to determine if they’re relevant to what we're looking for. Then, you would make a note of the offset and save the results to your address list at the bottom. I’ve done this before, but I wouldn’t recommend it unless you’ve already exhausted all other options.</p>
							<p>For now, let's try to spot the best starting point. Looking at the list of values, you’ll notice many that begin with 0, several that start with 2, but only one that begins with 1. This seems like a promising lead, so I’ll start my search here and see if it reveals a pointer that leads to a stable memory address.</p>
							<p>Running 'Find out what accesses this address' on this value reveals many instructions like <code>cmp [rdx], rax</code>, where <code>rdx</code> equals our pointer <code>01C4E4D40</code>. This is similar to what we saw earlier, except the offset is 0, meaning it’s equivalent to <code>cmp [rdx + 0], rax</code>. This will be important shortly.</p>
							<center>
							<a href="images/Reverse%20Engineering%20Dark%20Souls/FindingHealthPointer2.jpg" target="_Blank">
							<span><img src="images/Reverse%20Engineering%20Dark%20Souls/FindingHealthPointer2.jpg" class="EHG" alt="" /></span>
							</a>
							</center>
							<br>
							<p>Double-click the value to save it, then start a new scan using that value. You should now see even more pointers to this address, and one of them will be green indicating it’s a stack address, which is what we’re looking for. Save this one as well. With this stack pointer in hand, we can begin building a pointer chain that will automatically lead us to the correct health address, even between application runs.</p>
							<center>
							<a href="images/Reverse%20Engineering%20Dark%20Souls/FindingHealthPointer3.jpg" target="_Blank">
							<span><img src="images/Reverse%20Engineering%20Dark%20Souls/FindingHealthPointer3.jpg" class="EHG" alt="" /></span>
							</a>
							</center>
							<br>
							<p>To recap again we have a number of pointers that can be visualized as follows:</p>
							<ul> 
								<li><code>[DarkSoulsRemastered.exe + 1A31768] = 01C4E4D40</code></li>
								<li><code>[01C4E4D40 + 0] = 0D51B150</code></li>
								<li><code>0D51B150 + 3E8 = 0D51B538</code></li>
								<li><code>[0D51B538] = Health value</code></li>
							</ul>
							<p>But what does <code>DarkSoulsRemastered.exe + 1A31768</code> mean?</p>
							<p><code>DarkSoulsRemastered.exe</code> refers to the game’s main executable, which is loaded into memory when the game starts. Each executable or module has a base address, which is the starting point in memory where it’s loaded. Modules can also include Dynamic Link Libraries (DLLs), which are external files that the game loads to provide additional functionality.</p>
							<p>When we write <code>DarkSoulsRemastered.exe + 1A31768</code>, we’re using the base address of the game’s executable and adding the offset <code>1A31768</code> to find a specific memory address within the game.</p>
							<p>So, in this case, <code>DarkSoulsRemastered.exe + 1A31768</code> points to the memory address <code>01C4E4D40</code>, and from there, the pointer chain leads us to the health value. If we wanted to access memory from other modules, we could do so in a similar way by referencing the module name, such as <code>OtherModule.dll + Offset</code>.</p>
							<p>From this, we can construct the pointer chain in Cheat Engine:</p>
							<center>
							<a href="images/Reverse%20Engineering%20Dark%20Souls/FindingHealthPointer4.jpg" target="_Blank">
							<span><img src="images/Reverse%20Engineering%20Dark%20Souls/FindingHealthPointer4.jpg" class="EHG" alt="" /></span>
							</a>
							</center>
							<br>
							<p>Now that we have our health pointer, you can delete the other values and save this Cheat Engine table for future use. This example was relatively straightforward, but finding pointer chains can often be much more challenging, especially in modern games. Often, once you’ve found one value tied to the player (such as health), you might discover other related values (such as currency, levels, or position) stored nearby in memory, as they are often part of the same object or area of memory.</p>
							<p>However, this process is rarely that simple in more complex games. Here are some reasons why finding pointer chains can be more difficult:</p>
							<ol>
								<li><p><b>Anti-Cheat Mechanisms:</b> Many online or competitive games include anti-cheat mechanisms designed to prevent tampering with memory values. These mechanisms can detect when a debugger is attached, and games might crash or behave unpredictably if external programs like Cheat Engine attempt to modify in-game memory. Additionally, some anti-cheat software will actively block memory scanning and debugging tools, making it significantly harder to find and manipulate pointer chains.</p></li>
								<li><p><b>Code Obfuscation:</b> Some games employ code obfuscation techniques to make reverse engineering more difficult. This could involve obfuscating memory structures or instructions so that they don’t follow predictable patterns. For example, the game might randomize or encrypt pointer values, or use dynamically generated code that changes each time the game runs. This makes it much harder to find reliable pointer chains, as the memory layout may be entirely different from one session to the next.</p></li>
								<li><p><b>Games Using Interpreted Languages:</b> Games built using interpreted languages like Java or C# can also pose additional challenges. In these cases, memory allocation can be handled by a virtual machine (VM), which adds an extra layer of abstraction. The VM may move memory values around during runtime through techniques like garbage collection, making it difficult to track the actual pointer chains because memory addresses might change unpredictably.</p></li>
								<li><p><b>Deliberate Pointer Obfuscation:</b> Some games intentionally obscure their pointer chains as a defense against memory tampering. For example, the game might cycle through a list of pointers, with only one being valid at any given time. Accessing the invalid ones could result in incorrect values or even crash the game with a null reference exception or memory access violation. These rotating pointers make it extremely difficult to reliably locate the correct pointer chain, requiring advanced techniques and a deeper understanding of the game's memory architecture to bypass.</p></li>
								<li><p><b>Multi-Level Pointer Chains:</b> In more complex games, the pointer chain might not be as simple as one or two levels deep. You may encounter pointer chains that span several levels, with each pointer leading to another memory address that, in turn, points to the next one. This means that you’ll need to recursively trace through each level of pointers to reach the final value. Multi-level pointer chains can be very time-consuming to identify and map out correctly, especially in larger, more complex games.</p></li>
								<li><p><b>Dynamic Memory and ASLR:</b> Address Space Layout Randomization (ASLR) is a security feature used by many modern operating systems to randomly arrange the positions of key data areas, such as the base of executables and libraries in memory. This means that each time the game runs, the memory addresses of key components may change, making it harder to locate fixed pointers or pointer chains across different sessions. ASLR forces the reverse engineer to use techniques like base address calculation or signature scanning to find stable pointers.</p></li>
							</ol>
							<p><b>Fun Note:</b> One of the hardest games I've tried to reverse is Bloons Tower Defence 6... Seriously that game has some crazy anti-cheat going on.</p>
							<hr>
							<br>
							<p>To be continued...</p>
						</div>
					</div>

				<!-- Footer -->
					<footer id="footer">
						<div class="inner">
							<ul class="copyright">
								<li>&copy; Lily Raeburn. All rights reserved</li>
							</ul>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>